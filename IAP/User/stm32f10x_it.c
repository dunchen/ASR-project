/*******************************************************************************
** 文件名: 		stm32f10x_it.c
** 版本：  		1.0
** 工作环境: 	RealView MDK-ARM 4.14
** 作者: 		wuguoyana
** 生成日期: 	2011-04-29
** 功能:		相关的中断服务函数
** 相关文件:	stm32f10x_it.h
** 修改日志：	2011-04-29   创建文档
*******************************************************************************/
#include "stm32f10x_it.h"
#include "common.h"
/* 宏定义 --------------------------------------------------------------------*/
#define LED2   GPIO_Pin_6
#define LED3   GPIO_Pin_7
#define LED4   GPIO_Pin_8
#define LED5   GPIO_Pin_9

/******************************************************************************/
/*            Cortex-M3 处理器的相关服务函数                                  */
/******************************************************************************/

/*******************************************************************************
  * @函数名称	NMI_Handler
  * @函数说明   不可屏蔽中断发生的中断处理函数
  * @输入参数   无
  * @输出参数   无
  * @返回参数   无
*******************************************************************************/
void NMI_Handler(void)
{
}

/*******************************************************************************
  * @函数名称	HardFault_Handler
  * @函数说明   硬件错误发生的中断处理函数
  * @输入参数   无
  * @输出参数   无
  * @返回参数   无
*******************************************************************************/
void HardFault_Handler(void)
{
    SerialPutString("ERROR!!!!! \n\r");
    //当硬件错误发生时进入死循环 
    while (1)
    {
        //点亮LED指示错误
        GPIO_ResetBits(GPIOB, LED4 | LED5);//点亮LED2
    }
}

/*******************************************************************************
  * @函数名称	MemManage_Handler
  * @函数说明   内存管理中断发生的中断处理函数
  * @输入参数   无
  * @输出参数   无
  * @返回参数   无
*******************************************************************************/
void MemManage_Handler(void)
{
    //当内存管理中断发生时进入死循环 
    while (1)
    {
    }
}

/*******************************************************************************
  * @函数名称	BusFault_Handler
  * @函数说明   总线错误发生的中断处理函数
  * @输入参数   无
  * @输出参数   无
  * @返回参数   无
*******************************************************************************/
void BusFault_Handler(void)
{
    //当总线错误发生时进入死循环 
    while (1)
    {
    }
}

/*******************************************************************************
  * @函数名称	UsageFault_Handler
  * @函数说明   用户程序发生错误时的中断处理函数
  * @输入参数   无
  * @输出参数   无
  * @返回参数   无
*******************************************************************************/
void UsageFault_Handler(void)
{
    //当用户错误发生时进入死循环 
    while (1)
    {
    }
}

/*******************************************************************************
  * @函数名称	SVC_Handler
  * @函数说明   SVC调用中断发生的中断处理函数
  * @输入参数   无
  * @输出参数   无
  * @返回参数   无
*******************************************************************************/
void SVC_Handler(void)
{
}

/*******************************************************************************
  * @函数名称	DebugMon_Handler
  * @函数说明   调试监控中断发生的中断处理函数
  * @输入参数   无
  * @输出参数   无
  * @返回参数   无
*******************************************************************************/
void DebugMon_Handler(void)
{
}

/*******************************************************************************
  * @函数名称	PendSV_Handler
  * @函数说明   Pend SV中断发生的中断处理函数
  * @输入参数   无
  * @输出参数   无
  * @返回参数   无
*******************************************************************************/
void PendSV_Handler(void)
{
}

/*******************************************************************************
  * @函数名称	SysTick_Handler
  * @函数说明   SysTick中断发生的中断处理函数
  * @输入参数   无
  * @输出参数   无
  * @返回参数   无
*******************************************************************************/
void SysTick_Handler(void)
{
}

/******************************************************************************/
/*                 STM32F10x 外设 中断 服务函数                               */
/*  增加需要的外设中断函数在下面。中断的函数名字都已经在startup_stm32f10x_xx.s*/
/*  的文件中定义好了，请参照它来写。                                          */
/******************************************************************************/
/*
void USART1_IRQHandler(void)
{
  unsigned char Data_Temp=0;
	if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)
	{
		USART_ClearITPendingBit(USART1, USART_IT_RXNE);
	    Data_Temp = USART_ReceiveData(USART1);
	}
}
*/

/*******************************文件结束***************************************/
